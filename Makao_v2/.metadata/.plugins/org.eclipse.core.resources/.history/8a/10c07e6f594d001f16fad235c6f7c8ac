package tests;

import java.util.ArrayList;

import org.junit.* ;

import client.Performer;

import shared.Card;
import shared.CardStack;
import shared.Request;
import static org.junit.Assert.* ;

public class PerformerTest 
{
    @Test
    public void testWheterWeCanPutNotFunctionCardWithTheSameNameAsOnTheTopOfStack()
    {
    	Performer cs;
    		for (Card.Name name1 : Card.Name.values())
    		{
    			for (Card.Suit suit1 : Card.Suit.values())
    			{
    				for (Card.Name name2 : Card.Name.values())
    	    		{
    	    			for (Card.Suit suit2 : Card.Suit.values())
    	    			{
    	    				if (((name1==name2) || (suit1==suit2)) && (name1!=Card.Name.QUEEN) && (name2!=Card.Name.QUEEN))
    	    				{
    	    					Card[] selectedCards = null;
    	    			    	CardStack pack = new CardStack();
    	    			    	cs = new Performer(pack);
    	    			    	
    	    					selectedCards = new Card[] {new Card(name1,suit1)};
    	    					pack.push(new Card(name2,suit2));
    	    					cs.setSelection(selectedCards);    
    	    					Assert.assertTrue(cs.testSelection());
    	    				}
    	    				else Assert.assertFalse(false);
    	    			}
					}
    			}
    		}
    }
    @Test
    public void testWheterWeCan_NOT_PutCardWithTheAnotherSuitAndAnotherName()
    {
    	Performer cs;
    		for (Card.Name name1 : Card.Name.values())
    		{
    			for (Card.Suit suit1 : Card.Suit.values())
    			{
    				for (Card.Name name2 : Card.Name.values())
    	    		{
    	    			for (Card.Suit suit2 : Card.Suit.values())
    	    			{
    	    				if ((name1!=name2) && (suit1!=suit2) && (name1!=Card.Name.QUEEN) && (name2!=Card.Name.QUEEN))
    	    				{
    	    					Card[] selectedCards = null;
    	    			    	CardStack pack = new CardStack();
    	    			    	cs = new Performer(pack);
    	    			    	
    	    					selectedCards = new Card[] {new Card(name1,suit1)};
    	    					pack.push(new Card(name2,suit2));
    	    					cs.setSelection(selectedCards);    
    	    					Assert.assertFalse(cs.testSelection());
    	    				}
    	    				else Assert.assertFalse(false);
    	    			}
					}
    			}
    		}			  
    }
    @Test
    public void testWhetherCanPushIfOnStackTopIsQueen()
    {
    	Performer cs;
    
    		for (Card.Name name1 : Card.Name.values())
    		{
    			for (Card.Suit suit1 : Card.Suit.values())
    			{
    				for (Card.Suit suit2 : Card.Suit.values())
        			{
    					Card[] selectedCards = null;
    					CardStack pack = new CardStack();
    					cs = new Performer(pack);	    	
    					selectedCards = new Card[] {new Card(name1,suit1)};
    					pack.push(new Card(Card.Name.QUEEN,suit2));
    					cs.setSelection(selectedCards);    
    					Assert.assertTrue(cs.testSelection());
        			}
    	    	}
    		}
    		
    	
    }
    @Test
    public void testWhetherCanPushQueenOnStack()
    {
    	Performer cs;
    	for (Card.Name name1 : Card.Name.values())
		{
			for (Card.Suit suit1 : Card.Suit.values())
			{
				for (Card.Suit suit2 : Card.Suit.values())
    			{
    					Card[] selectedCards = null;
    					CardStack pack = new CardStack();
    					cs = new Performer(pack);
    	    			    	
    					selectedCards = new Card[] {new Card(Card.Name.QUEEN,suit2)};
    					pack.push(new Card(name1,suit1));
    					cs.setSelection(selectedCards);    
    					Assert.assertTrue(cs.testSelection());
        			}
    	    	}
    		}
    	
    }
    @Test(expected = NullPointerException.class)
    public void testIfSelectionEmptyDuringTest() throws NullPointerException
    {
    	CardStack stack = new CardStack();
		stack.push(new Card(Card.Name.ACE,Card.Suit.SPADE));
      	Performer cs = new Performer(stack);
    	cs.testSelection();
    }
    @Test(expected = NullPointerException.class)
    public void testIfStackNullDuringTest() throws NullPointerException
    {
	    Card[] selection = new Card[]{new Card(Card.Name.ACE,Card.Suit.SPADE)};
      	Performer cs = new Performer(null);
    	cs.testSelection();
    }
    @Test
    public void testWhetherCanPushCardIfServerHasGeneratedRequest()
    {
       for (byte i=0;i<3;i++)
       {
    	   for (Card.Name name1 : Card.Name.values())
   		   {
   				for (Card.Suit suit1 : Card.Suit.values())
   			    {
   					Request req = null;
   					if (i==0) req = new Request(i,name1);
   					if (i==1) req = new Request(i,suit1);
   					if (i==2) req = new Request(i);
   					CardStack stack = new CardStack();
   					stack.push(new Card(Card.Name.ACE,Card.Suit.CLUB));
   					Performer performer = new Performer(stack);
   					performer.setIncomingRequest(req);
   					for (Card.Name name : Card.Name.values())
   					{
   						for (Card.Suit suit : Card.Suit.values())
   						{
   							
   							Card card = null;
   							card = new Card(name,suit);
   							performer.setSelection(new Card[]{card});
   							if (Request.REQUEST_WAITING == i) Assert.assertFalse(performer.testSelection());
   							if ((card.getName() == Card.Name.QUEEN) && (Request.REQUEST_WAITING != i)) Assert.assertTrue(performer.testSelection());
   							if (Request.REQUEST_CARD_NAME == i)
   							{
   								if (card.getName().equals(req.getArg())) Assert.assertTrue(performer.testSelection()); 
   							}
   							if (Request.REQUEST_CARD_SUIT == i)
   							{
   								if (card.getSuit().equals(req.getArg())) Assert.assertTrue(performer.testSelection());
   							}				 		       		  
   						}
   					}
   			    }
   		   }
       }
    }
    @Test
    public void testWhetherSelectionCanHaveOnlyCardsWithSameName()
    {
        Card[] selection = null;		
        for (byte c_num = 1 ; c_num <= 4;c_num++)
        {	
        	selection = new Card[c_num];
        	CardStack cards = new CardStack();	
        	for (Card.Name name1 : Card.Name.values())
    		   {
    				for (Card.Suit suit1 : Card.Suit.values())
    			    {        			
    					Card card = null;        		
    					card = new Card(name,suit);
    			    }
        	    }
        	}
        }
       
    }
    @Test
    public void testWhetherCanMakeNameRequest()
    {
    	Performer perf = new Performer(null);
		for (Card.Name name : Card.Name.values())
		{
			for (Card.Suit suit : Card.Suit.values())
    		{	
				Card card = new Card(name,suit);					
				perf.setSelection(new Card[]{card});
				for (byte k=0; k<3; k++) 
 			    {
					//Object arg;
					//Request req;
					if (k==0) 
					{ 
						for (Card.Name name1 : Card.Name.values())							
						{  
							if (card.getName() == Card.Name.JACK)
							{  	   
								   if ((name1.equals(Card.Name.FIVE)) || 
									  (name1.equals(Card.Name.SIX))  ||
									  (name1.equals(Card.Name.SEVEN)) ||
									  (name1.equals(Card.Name.EIGHT)) ||
									  (name1.equals(Card.Name.NINE)) ||
									  (name1.equals(Card.Name.TEN))  ||
									  (name1.equals(Card.Name.QUEEN))) Assert.assertTrue(perf.setOutgoingRequest(new Request(k,name1)));
								   else Assert.assertFalse(perf.setOutgoingRequest(new Request(k,name1)));   
		    			    }
							else Assert.assertFalse(perf.setOutgoingRequest(new Request(k,name1)));
						}
					}
					
    			}			
    	    }
		}
    }
    @Test
    public void testWhetherCanMakeSuitRequest()
    {
    	Performer perf = new Performer(null);
		for (Card.Name name : Card.Name.values())
		{
			for (Card.Suit suit : Card.Suit.values())
    		{	
				Card card = new Card(name,suit);					
				perf.setSelection(new Card[]{card});
				for (byte k=0; k<3; k++) 
 			    {
					//Object arg;
					//Request req;
					if (k==1) 
					{ 
						for (Card.Suit name1 : Card.Suit.values())							
						{  
							if (card.getName() == Card.Name.ACE)
							{  	   
								   Assert.assertTrue(perf.setOutgoingRequest(new Request(k,name1)));
								  // else Assert.assertFalse(perf.setOutgoingRequest(new Request(k,name1)));   
		    			    }
							else Assert.assertFalse(perf.setOutgoingRequest(new Request(k,name1)));
						}
					}
					
    			}			
    	    }
		}
    }
}
